#include <iostream>
#include <fstream>
#include <sstream>
using namespace std;

int main()
{
	ofstream fout;
	unsigned int i = 0;
	for (unsigned int j = 0; j < 10; ++j)
	{
		for (unsigned int k = 0; k < 10; ++k)
		{
			++i;
			stringstream path;
			path << "../DX12Engine/Outside/testzone" << i << ".h";
			fout.open(path.str());
			if (fout.fail())
			{
				std::cout << "couldn't open file " << path.str();
				return -1;
			}

			fout << ""
				"#pragma once\n"
				"\n"
				"#include \"../BaseZone.h\"\n"
				"#include \"../PipelineStateObjects.h\"\n"
				"#include \"../Meshes.h\"\n"
				"#include \"../CriticalSection.h\"\n"
				"#include \"../TextureManager.h\"\n"
				"class SharedResources;\n"
				"\n"
				"#include \"../Light.h\"\n"
				"#include \"../TestZoneModels/highresplanemodel" << i << ".h\"\n"
				"\n"
				"class TestZone" << i << " : public BaseZone\n"
				"{\n"
				"	template<QueueType queueType>\n"
				"	static void textureLoadedCallbackHighDetail1(void* requester, BaseExecutor* executor)\n"
				"	{\n"
				"		auto zone = reinterpret_cast<TestZone" << i << "* const>(requester);\n"
				"		textureResourceUploadedJob<queueType, HDResources1, TestZone" << i << ", BaseZone::high>(requester, executor, zone->hdResources1);\n"
				"	}\n"
				"\n"
				"	static MeshesBase* zoneToMeshesHighDetail1(void* requester)\n"
				"	{\n"
				"		auto zone = reinterpret_cast<TestZone" << i << "* const>(requester);\n"
				"		return &zone->hdResources1->meshes;\n"
				"	}\n"
				"\n"
				"	static MeshesBase* resourcesToMeshesHighDetail1(void* requester)\n"
				"	{\n"
				"		auto resources = reinterpret_cast<HDResources1* const>(requester);\n"
				"		return &resources->meshes;\n"
				"	}\n"
				"\n"
				"	template<QueueType queueType>\n"
				"	static void vertexLoadedCallbackHighDetail1(void* requester, BaseExecutor* executor)\n"
				"	{\n"
				"		auto zone = reinterpret_cast<TestZone" << i << "* const>(requester);\n"
				"		vertexResourceUploadedJob<queueType, HDResources1, TestZone" << i << ", BaseZone::high, resourcesToMeshesHighDetail1>(requester, executor, zone->hdResources1);\n"
				"	}\n"
				"\n"
				"	template<QueueType queueType>\n"
				"	static void indexLoadedCallbackHighDetail1(void* requester, BaseExecutor* executor)\n"
				"	{\n"
				"		auto zone = reinterpret_cast<TestZone" << i << "* const>(requester);\n"
				"		indexResourceUploadedJob<queueType, HDResources1, TestZone" << i << ", BaseZone::high, resourcesToMeshesHighDetail1>(requester, executor, zone->hdResources1);\n"
				"	}\n"
				"\n"
				"	class HDResources1\n"
				"	{\n"
				"		friend class TestZone" << i << ";\n"
				"		friend class BaseZone;\n"
				"\n"
				"		constexpr static unsigned int numPositionTextureNormalTangentBitangentMeshes = 0u;\n"
				"		constexpr static unsigned int numPositionTextureNormalMeshes = 1u;\n"
				"		constexpr static unsigned int numPositionTextureMeshes = 0u;\n"
				"		constexpr static unsigned int numMeshes = numPositionTextureNormalTangentBitangentMeshes + numPositionTextureNormalMeshes + numPositionTextureMeshes;\n"
				"\n"
				"		constexpr static unsigned int numTextures = 1u;\n"
				"		constexpr static unsigned int numComponents = 4u;\n"
				"		constexpr static unsigned int textureIndices[numTextures] = { 4u };\n"
				"\n"
				"		class Textures\n"
				"		{\n"
				"			TextureManager* const textureManager;\n"
				"		public:\n"
				"			Textures(TextureManager* const textureManager, BaseExecutor* executor, void* requester, void(*resourceUploadedCallback)(void* const requester, BaseExecutor* const executor)) : textureManager(textureManager)\n"
				"			{\n"
				"				for (auto i = 0u; i < numTextures; ++i)\n"
				"				{\n"
				"					textureManager->loadTexture(textureIndices[i], requester, executor, resourceUploadedCallback);\n"
				"				}\n"
				"			}\n"
				"\n"
				"			~Textures()\n"
				"			{\n"
				"				for (unsigned int i = 0u; i < numTextures; ++i)\n"
				"				{\n"
				"					textureManager->unloadTexture(textureIndices[i]);\n"
				"				}\n"
				"			}\n"
				"		};\n"
				"\n"
				"		std::atomic<unsigned char> numComponentsLoaded = 0u;\n"
				"		std::atomic<unsigned char> numTexturesLoaded = 0u;\n"
				"		std::atomic<unsigned char> numVertexBuffersLoaded = 0u;\n"
				"		std::atomic<unsigned char> numIndexBuffersLoaded = 0u;\n"
				"\n"
				"		Meshes<numPositionTextureNormalTangentBitangentMeshes, numPositionTextureNormalMeshes, numPositionTextureMeshes, zoneToMeshesHighDetail1> meshes;\n"
				"		Textures textures;\n"
				"		D3D12Resource perObjectConstantBuffers;\n"
				"\n"
				"		Light light;\n"
				"\n"
				"		HighResPlaneModel" << i << " highResPlaneModel;\n"
				"\n"
				"\n"
				"		HDResources1(BaseExecutor* const executor, void(*textureLoadedCallback)(void* requester, BaseExecutor* executor),\n"
				"			void(*verticesLoadedCallback)(void* requester, BaseExecutor* executor), void(*indicesLoadedCallback)(void* requester, BaseExecutor* executor), void* zone);\n"
				"		~HDResources1();\n"
				"\n"
				"		void render(BaseExecutor* const executor);\n"
				"		void update(BaseExecutor* const executor);\n"
				"		void renderToTexture(BaseExecutor* const executor) {}\n"
				"\n"
				"		template<QueueType queueType>\n"
				"		static void staticLoad(void*const zone1, BaseExecutor*const executor)\n"
				"		{\n"
				"			TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "*const>(zone1);\n"
				"			try\n"
				"			{\n"
				"				zone->hdResources1 = (HDResources1*)malloc(sizeof(HDResources1));\n"
				"				new(zone->hdResources1) HDResources1(executor, textureLoadedCallbackHighDetail1<queueType>, vertexLoadedCallbackHighDetail1<queueType>, indexLoadedCallbackHighDetail1<queueType>, zone);\n"
				"\n"
				"				auto oldNumComponentsLoaded = zone->hdResources1->numComponentsLoaded.fetch_add(1u);\n"
				"				if (oldNumComponentsLoaded + 1u == HDResources1::numComponents)\n"
				"				{\n"
				"					zone->lastComponentLoaded<BaseZone::high, queueType>(executor);\n"
				"				}\n"
				"			}\n"
				"			catch (...)\n"
				"			{\n"
				"				if (zone->hdResources1)\n"
				"				{\n"
				"					delete zone->hdResources1;\n"
				"					zone->hdResources1 = nullptr;\n"
				"				}\n"
				"				throw;\n"
				"			}\n"
				"		}\n"
				"	};\n"
				"\n"
				"	void restart(BaseExecutor* const executor);\n"
				"\n"
				"\n"
				"	virtual void AddBackGroundLoadHighDetailJobs(BaseExecutor* const executor) override;\n"
				"	virtual void AddBackGroundLoadMediumDetailJobs(BaseExecutor* const executor) override;\n"
				"	virtual void AddBackGroundLoadLowDetailJobs(BaseExecutor* const executor) override;\n"
				"\n"
				"	virtual void AddBackGroundUnloadHighDetailJobs(BaseExecutor* const executor) override;\n"
				"	virtual void AddBackGroundUnloadMediumDetailJobs(BaseExecutor* const executor) override;\n"
				"	virtual void AddBackGroundUnloadLowDetailJobs(BaseExecutor* const executor) override;\n"
				"\n"
				"	virtual void AddPrimaryLoadHighDetailJobs(BaseExecutor* const executor) override;\n"
				"	virtual void AddPrimaryLoadMediumDetailJobs(BaseExecutor* const executor) override;\n"
				"	virtual void AddPrimaryLoadLowDetailJobs(BaseExecutor* const executor) override;\n"
				"\n"
				"	virtual void AddPrimaryUnloadHighDetailJobs(BaseExecutor* const executor) override;\n"
				"	virtual void AddPrimaryUnloadMediumDetailJobs(BaseExecutor* const executor) override;\n"
				"	virtual void AddPrimaryUnloadLowDetailJobs(BaseExecutor* const executor) override;\n"
				"\n"
				"	virtual void update(BaseExecutor* const executor) override;\n"
				"	virtual void renderToTexture(BaseExecutor* const executor) override;\n"
				"	virtual void render(BaseExecutor* const executor) override;\n"
				"public:\n"
				"	TestZone" << i << "();\n"
				"\n"
				"	HDResources1* hdResources1;\n"
				"};\n";


			std::cout << "testzone" << i << ".h finished\n";
			fout.close();

			stringstream path2;
			path2 << "../DX12Engine/Outside/testzone" << i << ".cpp";
			fout.open(path2.str());
			if (fout.fail())
			{
				std::cout << "couldn't open file " << path.str();
				return -1;
			}

			fout <<
				"#include \"testzone" << i << ".h\"\n"
				"#include \"../BaseExecutor.h\"\n"
				"#include \"../SharedResources.h\"\n"
				"#include \"../ID3D12ResourceMapFailedException.h\"\n"
				"\n"
				"TestZone" << i << "::TestZone" << i << "() :\n"
				"	BaseZone(), \n"
				"	hdResources1(nullptr) {}\n"
				"\n"
				"TestZone" << i << "::HDResources1::HDResources1(BaseExecutor* const executor, void(*textureLoadedCallback)(void* requester, BaseExecutor* executor),\n"
				"	void(*verticesLoadedCallback)(void* requester, BaseExecutor* executor), void(*indicesLoadedCallback)(void* requester, BaseExecutor* executor), void* zone) :\n"
				"	meshes({ L\"../DX12Engine/Meshes/HighResMesh1.mesh\" }, verticesLoadedCallback, indicesLoadedCallback, executor->sharedResources->graphicsEngine.graphicsDevice, &executor->ramToVramUploader, zone),\n"
				"	textures(&executor->sharedResources->textureManager, executor, zone, textureLoadedCallback),\n"
				"	light(DirectX::XMFLOAT4(0.1f, 0.1f, 0.1f, 1.0f), DirectX::XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f), DirectX::XMFLOAT3(0.0f, -0.894427191f, 0.447213595f)),\n"
				"	perObjectConstantBuffers(executor->sharedResources->graphicsEngine.graphicsDevice, []()\n"
				"{\n"
				"	D3D12_HEAP_PROPERTIES heapProperties;\n"
				"	heapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;\n"
				"	heapProperties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;\n"
				"	heapProperties.CreationNodeMask = 1u;\n"
				"	heapProperties.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;\n"
				"	heapProperties.VisibleNodeMask = 1u;\n"
				"	return heapProperties;\n"
				"}(), D3D12_HEAP_FLAGS::D3D12_HEAP_FLAG_NONE, []()	\n"
				"{\n"
				"	D3D12_RESOURCE_DESC resourceDesc;\n"
				"	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;\n"
				"	resourceDesc.Alignment = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT;\n"
				"	resourceDesc.Width = D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT; //might need changing\n"
				"	resourceDesc.Height = 1u;\n"
				"	resourceDesc.DepthOrArraySize = 1u;\n"
				"	resourceDesc.MipLevels = 1u;\n"
				"	resourceDesc.Format = DXGI_FORMAT::DXGI_FORMAT_UNKNOWN;\n"
				"	resourceDesc.SampleDesc = { 1u, 0u };\n"
				"	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;\n"
				"	resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;\n"
				"	return resourceDesc;\n"
				"}(), D3D12_RESOURCE_STATE_GENERIC_READ, nullptr)\n"
				"{\n"
				"	uint8_t* perObjectConstantBuffersCpuAddress;\n"
				"	D3D12_RANGE readRange{ 0u, 0u };\n"
				"	HRESULT hr = perObjectConstantBuffers->Map(0u, &readRange, reinterpret_cast<void**>(&perObjectConstantBuffersCpuAddress));\n"
				"	if (FAILED(hr)) throw ID3D12ResourceMapFailedException();\n"
				"	auto PerObjectConstantBuffersGpuAddress = perObjectConstantBuffers->GetGPUVirtualAddress();\n"
				"\n"
				"	new(&highResPlaneModel) HighResPlaneModel" << i << "(PerObjectConstantBuffersGpuAddress, perObjectConstantBuffersCpuAddress);\n"
				"}\n"
				"\n"
				"TestZone" << i << "::HDResources1::~HDResources1() {}\n"
				"\n"
				"void TestZone" << i << "::HDResources1::update(BaseExecutor* const executor) {}\n"
				"\n"
				"void TestZone" << i << "::HDResources1::render(BaseExecutor* const executor)\n"
				"{\n"
				"	UINT frameIndex = executor->frameIndex;\n"
				"	ID3D12GraphicsCommandList* const DirectCommandList = executor->opaqueDirectCommandList;\n"
				"	const auto sharedResources = executor->sharedResources;\n"
				"	UINT renderCount = 0u;\n"
				"\n"
				"	DirectCommandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n"
				"\n"
				"	if (highResPlaneModel.isInView(sharedResources->mainFrustum))\n"
				"	{\n"
				"		DirectCommandList->SetPipelineState(sharedResources->pipelineStateObjects.lightPSO1);\n"
				"\n"
				"		DirectCommandList->SetGraphicsRootConstantBufferView(2u, highResPlaneModel.vsPerObjectCBVGpuAddress);\n"
				"		DirectCommandList->SetGraphicsRootConstantBufferView(3u, highResPlaneModel.psPerObjectCBVGpuAddress);\n"
				"		DirectCommandList->IASetVertexBuffers(0u, 1u, &meshes[highResPlaneModel.meshIndex].vertexBufferView);\n"
				"		DirectCommandList->IASetIndexBuffer(&meshes[highResPlaneModel.meshIndex].indexBufferView);\n"
				"		DirectCommandList->DrawIndexedInstanced(meshes[highResPlaneModel.meshIndex].indexCount, 1u, 0u, 0, 0u);\n"
				"		++renderCount;\n"
				"	}\n"
				"	sharedResources->renderCount.fetch_add(renderCount);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddBackGroundLoadHighDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	executor->sharedResources->backgroundQueue.push(Job(this, &HDResources1::staticLoad<background>));\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddBackGroundUnloadHighDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	executor->sharedResources->backgroundQueue.push(Job(this, [](void*const zone1, BaseExecutor*const executor)\n"
				"	{\n"
				"		TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "*const>(zone1);\n"
				"		delete zone->hdResources1;\n"
				"		zone->hdResources1 = nullptr;\n"
				"		zone->lastComponentUnloaded<high, background>(executor);\n"
				"	}));\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddPrimaryLoadHighDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	executor->currentWorkStealingDeque->push(Job(this, &HDResources1::staticLoad<primary>));\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddPrimaryUnloadHighDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	executor->currentWorkStealingDeque->push(Job(this, [](void*const zone1, BaseExecutor*const executor)\n"
				"	{\n"
				"		TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "*const>(zone1);\n"
				"		delete zone->hdResources1;\n"
				"		zone->hdResources1 = nullptr;\n"
				"		zone->lastComponentUnloaded<high, primary>(executor);\n"
				"	}));\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddBackGroundLoadMediumDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	lastComponentLoaded<medium, background>(executor);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddBackGroundUnloadMediumDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	lastComponentUnloaded<medium, background>(executor);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddBackGroundLoadLowDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	lastComponentLoaded<low, background>(executor);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddBackGroundUnloadLowDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	lastComponentUnloaded<low, background>(executor);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddPrimaryLoadMediumDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	lastComponentLoaded<medium, background>(executor);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddPrimaryUnloadMediumDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	lastComponentUnloaded<medium, background>(executor);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddPrimaryLoadLowDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	lastComponentLoaded<low, background>(executor);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::AddPrimaryUnloadLowDetailJobs(BaseExecutor* const executor)\n"
				"{\n"
				"	lastComponentUnloaded<low, background>(executor);\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::restart(BaseExecutor* const executor)\n"
				"{\n"
				"	auto oldLevelOfDetail = levelOfDetail.load(std::memory_order::memory_order_seq_cst);\n"
				"	if (oldLevelOfDetail == 0u)\n"
				"	{\n"
				"		executor->nextWorkStealingDeque->push(Job(this, [](void*const zone1, BaseExecutor*const executor)\n"
				"		{\n"
				"			TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "* const>(zone1);\n"
				"			zone->hdResources1->update(executor);\n"
				"			executor->nextWorkStealingDeque->push(Job(zone1, [](void*const zone1, BaseExecutor*const executor)\n"
				"			{\n"
				"				TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "* const>(zone1);\n"
				"				zone->hdResources1->renderToTexture(executor);\n"
				"				executor->nextWorkStealingDeque->push(Job(zone1, [](void*const zone1, BaseExecutor*const executor)\n"
				"				{\n"
				"					TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "* const>(zone1);\n"
				"					zone->hdResources1->render(executor);\n"
				"					zone->restart(executor);\n"
				"				}));\n"
				"			}));\n"
				"		}));\n"
				"	}\n"
				"	else if (oldLevelOfDetail == 1u)\n"
				"	{\n"
				"		executor->nextWorkStealingDeque->push(Job(this, [](void*const zone1, BaseExecutor*const executor)\n"
				"		{\n"
				"			executor->nextWorkStealingDeque->push(Job(zone1, [](void*const zone1, BaseExecutor*const executor)\n"
				"			{\n"
				"				executor->nextWorkStealingDeque->push(Job(zone1, [](void*const zone1, BaseExecutor*const executor)\n"
				"				{\n"
				"					TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "* const>(zone1);\n"
				"					zone->restart(executor);\n"
				"				}));\n"
				"			}));\n"
				"		}));\n"
				"	}\n"
				"	else if (oldLevelOfDetail == 2u)\n"
				"	{\n"
				"		executor->nextWorkStealingDeque->push(Job(this, [](void*const zone1, BaseExecutor*const executor)\n"
				"		{\n"
				"			executor->nextWorkStealingDeque->push(Job(zone1, [](void*const zone1, BaseExecutor*const executor)\n"
				"			{\n"
				"				executor->nextWorkStealingDeque->push(Job(zone1, [](void*const zone1, BaseExecutor*const executor)\n"
				"				{\n"
				"					TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "* const>(zone1);\n"
				"					zone->restart(executor);\n"
				"				}));\n"
				"			}));\n"
				"		}));\n"
				"	}\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::update(BaseExecutor* const executor)\n"
				"{\n"
				"	executor->nextWorkStealingDeque->push(Job(this, [](void*const zone1, BaseExecutor*const executor)\n"
				"	{\n"
				"		executor->nextWorkStealingDeque->push(Job(zone1, [](void*const zone1, BaseExecutor*const executor)\n"
				"		{\n"
				"			TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "* const>(zone1);\n"
				"			zone->restart(executor);\n"
				"		}));\n"
				"	}));\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::renderToTexture(BaseExecutor* const executor)\n"
				"{\n"
				"	executor->nextWorkStealingDeque->push(Job(this, [](void*const zone1, BaseExecutor*const executor)\n"
				"	{\n"
				"		TestZone" << i << "* const zone = reinterpret_cast<TestZone" << i << "* const>(zone1);\n"
				"		zone->restart(executor);\n"
				"	}));\n"
				"}\n"
				"\n"
				"void TestZone" << i << "::render(BaseExecutor* const executor)\n"
				"{\n"
				"	restart(executor);\n"
				"}";

			std::cout << "testzone" << i << ".cpp finished\n";
			fout.close();
		}
	}
	std::cout << "finished";
}